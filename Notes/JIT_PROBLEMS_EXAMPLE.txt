This demonstrates the JIT's poor handling of the indirection in wrapping a
Vector4f:

class Vector4Test
{
	static void OpMultiply (int times)
	{
		Vector4 a = new Vector4 (1.1f, 1.11f, 1.12f, 1.13f);
		Vector4 result = new Vector4 (1, 2, 3, 4);
		for (int i = 0; i < times; i++) {
			result = result * a;
		}
	}
}

struct Vector4
{
	Vector4f v4;
	Vector4 (Vector4f v4) { this.v4 = v4; }
	public Vector4 (float x, float y, float x, float w) { this.v4 = new Vector4f (x, y, z, w); }
        public static Vector4f operator * (Vector4 a, Vector4 b) { return new Vector4 (a.v4 * b.v4); }
}

It does not inline the op_Multiply method, and the method is full of redundancies:

o_GameMath_Vector4_op_Multiply:
0000000000000000        pushq   %rbp
0000000000000001        movl    %esp,%ebp
0000000000000003        subl    $0x28,%esp
0000000000000006        movups  0x0c(%rbp),%xmm0
000000000000000a        movups  0x1c(%rbp),%xmm1
000000000000000e        mulps   %xmm1,%xmm0
0000000000000011        movl    $0x00000000,0xe0(%rbp)
0000000000000018        movl    $0x00000000,0xe4(%rbp)
000000000000001f        movl    $0x00000000,0xe8(%rbp)
0000000000000026        movl    $0x00000000,0xec(%rbp)
000000000000002d        movups  %xmm0,0xe0(%rbp)
0000000000000031        movl    0xe0(%rbp),%eax
0000000000000034        movl    %eax,0xf0(%rbp)
0000000000000037        movl    0xe4(%rbp),%eax
000000000000003a        movl    %eax,0xf4(%rbp)
000000000000003d        movl    0xe8(%rbp),%eax
0000000000000040        movl    %eax,0xf8(%rbp)
0000000000000043        movl    0xec(%rbp),%eax
0000000000000046        movl    %eax,0xfc(%rbp)
0000000000000049        movl    0x08(%rbp),%eax
000000000000004c        movl    0xf0(%rbp),%ecx
000000000000004f        movl    %ecx,(%rax)
0000000000000051        movl    0xf4(%rbp),%ecx
0000000000000054        movl    %ecx,0x04(%rax)
0000000000000057        movl    0xf8(%rbp),%ecx
000000000000005a        movl    %ecx,0x08(%rax)
000000000000005d        movl    0xfc(%rbp),%ecx
0000000000000060        movl    %ecx,0x0c(%rax)
0000000000000063        leave
0000000000000064        retl    $0x0004

If we force inlineing with MONO_INLINELIMIT=100, then the function
is inlined but there are still huge amounts of redundancies:

chmark_Vector4Test_OpMultiply:
0000000000000000        pushq   %rbp
0000000000000001        movl    %esp,%ebp
0000000000000003        pushq   %rdi
0000000000000004        pushq   %rsi
0000000000000005        subl    $0x000000a0,%esp
000000000000000b        movl    0x08(%rbp),%edi
000000000000000e        movl    $0x00000000,0xffffff68(%rbp)
0000000000000018        movl    $0x00000000,0xffffff6c(%rbp)
0000000000000022        movl    $0x00000000,0xffffff70(%rbp)
000000000000002c        movl    $0x00000000,0xffffff74(%rbp)
0000000000000036        movl    $0x00000000,0xffffff78(%rbp)
0000000000000040        movl    $0x00000000,0xffffff7c(%rbp)
000000000000004a        movl    $0x00000000,0x80(%rbp)
0000000000000051        movl    $0x00000000,0x84(%rbp)
0000000000000058        flds    0x00868fc4(%rip)
000000000000005e        flds    0x00868fcc(%rip)
0000000000000064        flds    0x00868fd4(%rip)
000000000000006a        flds    0x00868fdc(%rip)
0000000000000070        fxch    %st(3)
0000000000000072        fstps   0xffffff64(%rbp)
0000000000000078        fxch    %st(1)
000000000000007a        fstps   0xffffff60(%rbp)
0000000000000080        fstps   0xffffff5c(%rbp)
0000000000000086        fstps   0xffffff58(%rbp)
000000000000008c        flds    0xffffff64(%rbp)
0000000000000092        flds    0xffffff60(%rbp)
0000000000000098        flds    0xffffff5c(%rbp)
000000000000009e        flds    0xffffff58(%rbp)
00000000000000a4        fstps   0x94(%rbp)
00000000000000a7        fstps   0x90(%rbp)
00000000000000aa        fstps   0x8c(%rbp)
00000000000000ad        fstps   0x88(%rbp)
00000000000000b0        movups  0x88(%rbp),%xmm0
00000000000000b4        movups  %xmm0,0xffffff68(%rbp)
00000000000000bb        fld1
00000000000000bd        flds    0x00868fec(%rip)
00000000000000c3        flds    0x00868ff4(%rip)
00000000000000c9        flds    0x00868ffc(%rip)
00000000000000cf        fxch    %st(3)
00000000000000d1        fstps   0xffffff58(%rbp)
00000000000000d7        fxch    %st(1)
00000000000000d9        fstps   0xffffff5c(%rbp)
00000000000000df        fstps   0xffffff60(%rbp)
00000000000000e5        fstps   0xffffff64(%rbp)
00000000000000eb        flds    0xffffff58(%rbp)
00000000000000f1        flds    0xffffff5c(%rbp)
00000000000000f7        flds    0xffffff60(%rbp)
00000000000000fd        flds    0xffffff64(%rbp)
0000000000000103        fstps   0x94(%rbp)
0000000000000106        fstps   0x90(%rbp)
0000000000000109        fstps   0x8c(%rbp)
000000000000010c        fstps   0x88(%rbp)
000000000000010f        movups  0x88(%rbp),%xmm0
0000000000000113        movups  %xmm0,0xffffff78(%rbp)
000000000000011a        xorl    %esi,%esi
000000000000011c        jmp     0x000001e4
0000000000000121        leal    0x00000000(%rsp),%esp
0000000000000128        movl    0xffffff78(%rbp),%eax
000000000000012e        movl    %eax,0xc8(%rbp)
0000000000000131        movl    0xffffff7c(%rbp),%eax
0000000000000137        movl    %eax,0xcc(%rbp)
000000000000013a        movl    0x80(%rbp),%eax
000000000000013d        movl    %eax,0xd0(%rbp)
0000000000000140        movl    0x84(%rbp),%eax
0000000000000143        movl    %eax,0xd4(%rbp)
0000000000000146        movl    0xffffff68(%rbp),%eax
000000000000014c        movl    %eax,0xd8(%rbp)
000000000000014f        movl    0xffffff6c(%rbp),%eax
0000000000000155        movl    %eax,0xdc(%rbp)
0000000000000158        movl    0xffffff70(%rbp),%eax
000000000000015e        movl    %eax,0xe0(%rbp)
0000000000000161        movl    0xffffff74(%rbp),%eax
0000000000000167        movl    %eax,0xe4(%rbp)
000000000000016a        movl    0xc8(%rbp),%eax
000000000000016d        movl    %eax,0x98(%rbp)
0000000000000170        movl    0xcc(%rbp),%eax
0000000000000173        movl    %eax,0x9c(%rbp)
0000000000000176        movl    0xd0(%rbp),%eax
0000000000000179        movl    %eax,0xa0(%rbp)
000000000000017c        movl    0xd4(%rbp),%eax
000000000000017f        movl    %eax,0xa4(%rbp)
0000000000000182        movl    0xd8(%rbp),%eax
0000000000000185        movl    %eax,0xa8(%rbp)
0000000000000188        movl    0xdc(%rbp),%eax
000000000000018b        movl    %eax,0xac(%rbp)
000000000000018e        movl    0xe0(%rbp),%eax
0000000000000191        movl    %eax,0xb0(%rbp)
0000000000000194        movl    0xe4(%rbp),%eax
0000000000000197        movl    %eax,0xb4(%rbp)
000000000000019a        movups  0x98(%rbp),%xmm0
000000000000019e        movups  0xa8(%rbp),%xmm1
00000000000001a2        mulps   %xmm1,%xmm0
00000000000001a5        movl    $0x00000000,0xb8(%rbp)
00000000000001ac        movl    $0x00000000,0xbc(%rbp)
00000000000001b3        movl    $0x00000000,0xc0(%rbp)
00000000000001ba        movl    $0x00000000,0xc4(%rbp)
00000000000001c1        movups  %xmm0,0xb8(%rbp)
00000000000001c5        movl    0xb8(%rbp),%eax
00000000000001c8        movl    %eax,0xffffff78(%rbp)
00000000000001ce        movl    0xbc(%rbp),%eax
00000000000001d1        movl    %eax,0xffffff7c(%rbp)
00000000000001d7        movl    0xc0(%rbp),%eax
00000000000001da        movl    %eax,0x80(%rbp)
00000000000001dd        movl    0xc4(%rbp),%eax
00000000000001e0        movl    %eax,0x84(%rbp)
00000000000001e3        cmpl    %edi,%r14d
00000000000001e6        jl      0x100000128
00000000000001ec        leal    0xf8(%rbp),%esp
00000000000001ef        popq    %rsi
00000000000001f0        popq    %rdi
00000000000001f1        leave
00000000000001f2        ret

*** USING MONO.SIMD DIRECTLY ***
But if we use Mono.Simd directly, the JIT'd code is much better, and it's 5x faster.

public static void OpMultiply (int times)
{
	Mono.Simd.Vector4f a = new Mono.Simd.Vector4f (1.1f, 1.11f, 1.12f, 1.13f);
	Mono.Simd.Vector4f result = new Mono.Simd.Vector4f (1, 2, 3, 4);
	for (int i = 0; i < times; i++) {
		result = result * a;
	}
}

0000000000000000        pushq   %rbp
0000000000000001        movl    %esp,%ebp
0000000000000003        pushq   %rdi
0000000000000004        pushq   %rsi
0000000000000005        subl    $0x40,%esp
0000000000000008        movl    0x08(%rbp),%edi
000000000000000b        flds    0x0105ddc4(%rip)
0000000000000011        flds    0x0105ddcc(%rip)
0000000000000017        flds    0x0105ddd4(%rip)
000000000000001d        flds    0x0105dddc(%rip)
0000000000000023        fstps   0xe4(%rbp)
0000000000000026        fstps   0xe0(%rbp)
0000000000000029        fstps   0xdc(%rbp)
000000000000002c        fstps   0xd8(%rbp)
000000000000002f        movups  0xd8(%rbp),%xmm0
0000000000000033        movups  %xmm0,0xc8(%rbp)
0000000000000037        fld1
0000000000000039        flds    0x0105ddec(%rip)
000000000000003f        flds    0x0105ddf4(%rip)
0000000000000045        flds    0x0105ddfc(%rip)
000000000000004b        fstps   0xe4(%rbp)
000000000000004e        fstps   0xe0(%rbp)
0000000000000051        fstps   0xdc(%rbp)
0000000000000054        fstps   0xd8(%rbp)
0000000000000057        movups  0xd8(%rbp),%xmm0
000000000000005b        movups  %xmm0,0xb8(%rbp)
000000000000005f        xorl    %esi,%esi
0000000000000061        jmp     0x00000078
0000000000000063        leal    0x00(%rsp),%esp
0000000000000067        nop
0000000000000068        movups  0xb8(%rbp),%xmm0
000000000000006c        movups  0xc8(%rbp),%xmm1
0000000000000070        mulps   %xmm1,%xmm0
0000000000000073        movups  %xmm0,0xb8(%rbp)
0000000000000077        cmpl    %edi,%r14d
000000000000007a        jl      0x100000068
000000000000007c        leal    0xf8(%rbp),%esp
000000000000007f        popq    %rsi
0000000000000080        popq    %rdi
0000000000000081        leave
0000000000000082        ret
